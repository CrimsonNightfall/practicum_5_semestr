## Обходы графов

### A. Обход в глубину

Дан неориентированный невзвешенный граф. Для него вам необходимо найти количество вершин, лежащих в одной компоненте связности с данной вершиной (считая эту вершину). Используйте алгоритм обхода в глубину. Опишите класс `TGraph` с методами для чтения из потока ввода `ReadFromStream(std::istream &stream)`, нахождения компоненты связности `GetConnectedComponent(uint32_t vertex) const`, а также другими вспомогательными приватными методами (например, `DepthFirstSearch`). При использовании отличного от **Yandex C++ Style Guide** стиля кодирования именование классов и методов может отличаться.

В первой строке входных данных содержатся два числа: _N_ и _S_ (1 ≤ _N_ ≤ 100; 1 ≤ _S_ ≤ N), где _N_ – количество вершин графа, а _S_ – заданная вершина. В следующих _N_ строках записано по _N_ чисел – матрица смежности графа, в которой **0** означает отсутствие ребра между вершинами, а **1** – его наличие. Гарантируется, что на главной диагонали матрицы всегда стоят нули.

Выведите одно целое число – искомое количество вершин.

**Примеры**

Входные данные
```
3 1
0 1 1
1 0 0
1 0 0
```
Результат работы
```
3
```

### B. Обход в ширину

Одна из Сверхсекретных организаций, чье название мы не имеем право разглашать, представляет собой сеть из _N_ подземных бункеров, соединенных равными по длине туннелями, по которым из любого бункера можно добраться до любого другого (не обязательно напрямую). Связь с внешним миром осуществляется через специальные засекреченные выходы, которые расположены в некоторых из бункеров. Организации понадобилось составить план эвакуации персонала на случай экстренной ситуации. Для этого для каждого из бункеров необходимо узнать, сколько времени потребуется для того, чтобы добраться до ближайшего из выходов. Вам, как специалисту по таким задачам, поручено рассчитать необходимое время для каждого из бункеров по заданному описанию помещения Сверхсекретной организации. Для вашего же удобства бункеры занумерованы числами от _1_ до _N_.

Как и в предыдущей задаче, используйте ООП. Реализуйте класс `TGraph` с методом `BreadthFirstSearch(const std::vector<uint32_t> &startVertices) const`, возвращающим вектор расстояний от заданного множества вершин до всех вершин графа. Класс графа должен иметь понятный интерфейс, т. е. уметь вычислять расстояния от любого заданного множества вершин до всех остальных, хранить в нем начальные вершины не стоит. Реализуйте отдельной функцией `ReadExits(std::istream &stream)` чтение выходов. Чтение графа может быть реализовано как методом класса `ReadFromStream(std::istream &stream)`, так и в отдельной функции чтения и построения графа, возвращающей экземпляр класса `TGraph`.

Сначала вводятся два натуральных числа _N_, _K_ (1 ≤ _N_ ≤ 100000, 1 ≤ _K_ ≤ N) — количество бункеров и количество выходов соответственно. Далее через пробел записаны _K_ различных чисел от _1_ до _N_, обозначающих номера бункеров, в которых расположены выходы. Потом идет число _M_ (1 ≤ _M_ ≤ 100000) — количество туннелей. Далее вводятся _M_ пар чисел – номера бункеров, соединенных туннелем. По каждому из туннелей можно двигаться в обе стороны. В организации не существует туннелей, ведущих из бункера в самого себя, зато может существовать более одного туннеля между парой бункеров.

Выведите _N_ чисел, разделенных пробелом — для каждого из бункеров минимальное время, необходимое чтобы добраться до выхода. Считайте, что время перемещения по одному туннелю равно _1_.

**Примеры**

Входные данные
```
3
1
2
3
1 2
3 1
2 3
```
Результат работы
```
1 0 1
```

Входные данные
```
10
2
10 8
9
6 7
7 5
5 8
8 1
1 10
10 3
3 4
4 9
9 2
```
Результат работы
```
1 4 1 2 1 3 2 0 3 0
```

### C. Наличие цикла

Дан ориентированный граф. Используя алгоритм обхода в глубину, требуется определить, есть ли в нем цикл. Реализуйте класс `TGraph` с приватным методом `DepthFirstSearch` и публичным методом `bool HasCycle() const`.

В первой строке вводится число вершин _N_ ≤ 50. Далее в _N_ строках следуют по _N_ чисел, каждое из которых – _0_ или _1_. _j_-ое число в _i_-ой строке равно _1_ тогда и только тогда, когда существует ребро, идущее из _i_-ой вершины в _j_-ую. Гарантируется, что на диагонали матрицы будут стоять нули.

Выведите _0_, если в заданном графе цикла нет, и _1_, если он есть.

**Примеры**

Входные данные
```
3
0 1 0
0 0 1
0 0 0
```
Результат работы
```
0
```

Входные данные
```
3
0 1 0
0 0 1
1 0 0
```
Результат работы
```
1
```

### D. Топологическая сортировка

Группа солдат-новобранцев прибыла в армейскую часть N666. После знакомства с прапорщиком стало очевидно, что от работ на кухне по очистке картофеля спасти солдат может только чудо. Прапорщик, будучи не в состоянии запомнить фамилии, пронумеровал новобранцев от _1_ до _N_. После этого он велел им построиться по росту (начиная с самого высокого). С этой несложной задачей могут справиться даже совсем необученные новобранцы, да вот беда, прапорщик уверил себя, что знает про некоторых солдат, кто из них кого выше, и это далеко не всегда соответствует истине. После трех дней обучения новобранцам удалось выяснить, что знает (а точнее, думает, что знает) прапорщик. Помогите им, используя эти знания, построиться так, чтобы товарищ прапорщик остался доволен.

Реализуйте класс `TGraph`, интерфейс класса продумайте самостоятельно.

Сначала на вход программы поступают числа _N_ и _M_ (2 ≤ _N_ ≤ 100, 1 ≤ _M_ ≤ 5000) – количество солдат в роте и количество пар солдат, про которых прапорщик знает, кто из них выше. Далее идут эти пары чисел _A_ и _B_ по одной на строке (1 ≤ _A_, _B_ ≤ _N_), что означает, что, по мнению прапорщика, солдат _A_ выше, чем _B_. Не гарантируется, что все пары чисел во входных данных различны.

В первой строке выведите **Yes** (если можно построиться так, чтобы прапорщик остался доволен) или **No** (если нет). После ответа **Yes** на следующей строке выведите _N_ чисел, разделенных пробелами, - одно из возможных построений.

**Примеры**

Входные данные
```
4 5
1 2
2 3
3 4
1 4
4 1
```
Результат работы
```
No
```

### E. Конденсация графа

Вам задан ориентированный граф с _N_ вершинами и _M_ ребрами (1 ≤ _N_ ≤ 20000, 1 ≤ _M_ ≤ 200000). Найдите компоненты сильной связности заданного графа и топологически отсортируйте его конденсацию. Реализуйте класс `TGraph` с необходимым публичным интерфейсом и приватными полями и методами.

Граф задан во входном файле следующим образом: первая строка содержит числа _N_ и _M_. Каждая из следующих _M_ строк содержит описание ребра — два целых числа из диапазона от _1_ до _N_ — номера начала и конца ребра.

На первой строке выведите число _K_ — количество компонент сильной связности в заданном графе. На следующей строке выведите _N_ чисел — для каждой вершины выведите номер компоненты сильной связности, которой принадлежит эта вершина. Компоненты сильной связности должны быть занумерованы таким образом, чтобы для любого ребра номер компоненты сильной связности его начала не превышал номера компоненты сильной связности его конца.

**Примеры**

Входные данные
```
10 19
1 4
7 8
5 10
8 9
9 6
2 6
6 2
3 8
9 2
7 2
9 7
4 5
3 6
7 3
6 7
10 8
10 1
2 9
2 7
```
Результат работы
```
2
1 2 2 1 1 2 2 2 2 1
```

### F. Эйлеров цикл

Для решения транспортной проблемы в некотором городе до недавнего времени использовались _N_ (_N_ ≤ 100000) автобусных маршрутов. Каждый маршрут начинался на одной из _M_ (_M_ ≤ 100000) площадей и там же заканчивался. В процессе проезда по маршруту автобус мог несколько раз проезжать одну и ту же площадь, и даже мог проезжать более одного раза по одной и той же улице в одном и том же направлении. В определенный момент местные власти решили сократить количество автобусных маршрутов в городе до одного. По их мнению, должен был остаться лишь один маршрут, который проходил бы по всем улицам, по которым раньше проходили автобусные маршруты, причем в том же направлении (но не обязательно в том же порядке). Если по каким-либо улицам автобусы ездили в обоих направлениях, то и новый маршрут должен проходить по этим улицам в обоих направлениях. По тем улицам и в тех направлениях, по которым раньше автобусы не ездили, новый маршрут проходить не должен. Однако так как контролеров увольнять нельзя, власти решили, что по каждой улице в каждом направлении новый маршрут должен проходить столько раз, сколько по ней проходили все старые маршруты, вместе взятые. Требуется написать программу, которая для заданных исходных данных определяет требуемый местным властям автобусный маршрут.

Реализуйте класс `TGraph`, интерфейс класса продумайте самостоятельно.

Входной файл состоит из следующей последовательности строк. Первая строка содержит число _N_ – количество автобусных маршрутов, _M_ – количество площадей. Каждая из последующих _N_ строк служит для описания соответствующего автобусного маршрута и содержит сначала число _k_ (_k_ ≤ 100000), определяющее количество элементов маршрута, а затем _k + 1_ чисел, задающих номера площадей, которые последовательно проезжает автобус на этом маршруте. Общая длина маршрутов не более 100000 улиц. При описании маршрута всегда задаются номера первой и последней площади маршрута, причем они всегда совпадают.

Выходной файл должен содержать либо описание нового маршрута в том же формате, что используется во входном файле, либо одно число _0_, если организовать требуемый маршрут не удастся.

**Примеры**

Входные данные
```
2 5
6  1 2 3 4 3 2 1
2  4 5 4
```
Результат работы
```
9 1 2 3 4 5 4 3 2 1
```
