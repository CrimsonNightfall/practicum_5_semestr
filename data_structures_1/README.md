## Структуры данных 1

### A. Бинарное дерево поиска

Реализуйте бинарное дерево поиска для целых чисел. Программа получает на вход последовательность целых чисел и строит из них дерево. Элементы в деревья добавляются в соответствии с результатом поиска их места. Если элемент уже существует в дереве, добавлять его не надо. Балансировка дерева не производится.

На вход программа получает последовательность натуральных чисел. Последовательность завершается числом _0_, которое означает конец ввода, и добавлять его в дерево не надо.

Выведите единственное число – высоту получившегося дерева.

**Примеры**

Входные данные
```
7 3 2 1 9 5 4 6 8 0
```
Результат работы
```
4
```

### B. Куча

Отсортируйте данный массив. Используйте пирамидальную сортировку. Использовать готовые реализации пирамиды запрещается.

Первая строка входных данных содержит количество элементов в массиве _N_, _N_ ≤ 10^5. Далее задаются _N_ целых чисел, не превосходящих по абсолютной величине 10^9.

Выведите эти числа в порядке неубывания.

**Примеры**

Входные данные
```
5
5 4 3 2 1
```
Результат работы
```
1 2 3 4 5
```

### C. Провода

Дано _N_ отрезков провода длиной _L_1_, _L_2_, _..._, _L_N_ сантиметров. Требуется с помощью разрезания получить из них _K_ равных отрезков как можно большей длины, выражающейся целым числом сантиметров. Если нельзя получить _K_ отрезков длиной даже _1_ см, вывести _0_.

В первой строке находятся числа _N_ и _К_. В следующих _N_ строках - _L_1_, _L_2_, _..._, _L_N_, по одному числу в строке. Ограничения: 1 ≤ _N_ ≤ 10^4, 1 ≤ _K_ ≤ 10^4, 100 ≤ _L_i_ ≤ 10^7, все числа целые.

Вывести одно число - полученную длину отрезков.

**Примеры**

Входные данные
```
4 11
802
743
457
539
```
Результат работы
```
200
```

### D. Хэширование

Реализуйте структуру данных типа "множество строк". Хранимые строки – непустые последовательности длиной не более 10 символов, состоящие из строчных латинских букв. Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству. Максимальное количество элементов в хранимом множестве не превосходит 10^6. Использовать готовые структуры данных запрещается, необходимо собственноручно реализовать хэш-таблицу. Хэш от строки можно считать любой, например, полиномиальный.

Каждая строка входных данных задает одну операцию над множеством. Запись операции состоит из типа операции и следующей за ним через пробел строки, над которой проводится операция. Тип операции – один из трех символов: **+** означает добавление данной строки в множество; **-** означает удаление строки из множества; **?** означает проверку принадлежности данной строки множеству. Общее количество операций во входном файле не превосходит 10^6. Список операций завершается строкой, в которой записан один символ **#** – признак конца входных данных. При добавлении элемента в множество **НЕ ГАРАНТИРУЕТСЯ**, что он отсутствует в этом множестве. При удалении элемента из множества **НЕ ГАРАНТИРУЕТСЯ**, что он присутствует в этом множестве.

Программа должна вывести для каждой операции типа **?** одну из двух строк **YES** или **NO**, в зависимости от того, встречается ли данное слово в нашем множестве.

**Примеры**

Входные данные
```
+ hello
+ bye
? bye
- bye
? bye
? hello
#
```
Результат работы
```
YES
NO
YES
```

### E. Динамическое программирование (1 параметр)

В дощечке в один ряд вбиты гвоздики. Любые два гвоздика можно соединить ниточкой. Требуется соединить некоторые пары гвоздиков ниточками так, чтобы к каждому гвоздику была привязана хотя бы одна ниточка, а суммарная длина всех ниточек была минимальна.

В первой строке входных данных записано число _N_ — количество гвоздиков (2 ≤ _N_ ≤ 100). В следующей строке заданы _N_ чисел — координаты всех гвоздиков (неотрицательные целые числа, не превосходящие 10000).

Выведите единственное число — минимальную суммарную длину всех ниточек.

**Примеры**

Входные данные
```
5
4 10 0 12 2
```
Результат работы
```
6
```

### F. Динамическое программирование (2 параметра)

Дана текстовая строка. С ней можно выполнять следующие операции:
1. Заменить один символ строки на другой символ.
2. Удалить один произвольный символ.
3. Вставить произвольный символ в произвольное место строки.
Например, при помощи первой операции из строки **СОК** можно получить строку **СУК**, при помощи второй операции - строку **ОК**, при помощи третьей операции - строку **СТОК**. Минимальное количество таких операций, при помощи которых можно из одной строки получить другую, называется стоимостью редактирования или расстоянием Левенштейна. Определите расстояние Левенштейна для двух данных строк.

Программа получает на вход две строки, длина каждой из которых не превосходит 1000 символов, строки состоят только из заглавных латинских букв.

Требуется вывести одно число – расстояние Левенштейна для данных строк.

**Примеры**

Входные данные
```
ABCDEFGH
ACDEXGIH
```
Результат работы
```
3
```

### G. Выпуклая оболочка

На плоскости даны _N_ точек. Вам требуется построить выпуклую оболочку данного множества точек. Если _N_ нечетно, то оболочку нужно выводить в порядке обхода по часовой стрелке, иначе — против часовой стрелки.

Первая строка содержит количество точек _N_, 1 ≤ _N_ ≤ 20000. Каждая из последующих _N_ строк содержит два целых числа — координаты _x_i_ и _y_i_. Все числа по модулю не превосходят 10^4.

Выходной файл должен иметь тот же формат, что и входной, и должен содержать выпуклую оболочку. Количество точек в выходном файле должно быть минимально возможным.

**Примеры**

Входные данные
```
4
0 0
3 4
3 1
6 0
```
Результат работы
```
3
6 0
3 4
0 0
```
